%!TEX root = ../hauptdatei.tex
\chapter{Implementierung}
In diesem Kapitel wird beschrieben, wie die Backend Komponente und die zwei Frontend Komponenten, eine iOS App sowie ein Web Admin-Dashboard, als Referenz Implementierung entwickelt wird. 

\section{Backend}
Das Backend des Bäckerei Systems ist die zentrale Datenverwaltung, durch die neue Datensätze angelegt oder bestehende Datensätze abgerufen, bearbeitet oder gelöscht werden können. Um neue Datensätze nachhaltig speichern zu können, besitzt das Backend eine Datenbank.
\\
Im Folgenden wird beschrieben, aus welchen Hauptbestandteilen sich das Spring Backend zusammensetzt.
Diese Hauptbestandteile sind die Repository Klassen, die Service Klassen und die Controller Klassen.
Die Controller Klassen nutzen die Service Klassen und die Service Klassen nutzen die Repository Klassen als Abstraktionsschicht über der Datenbank.

\clearpage

\subsubsection{Repository Ebene}
Wie bereits beschrieben, stellt die Repository Ebene eine direkte Abstraktionsschicht der Datenbank dar.
Um eine Repository Klasse erstellen zu können, muss einem Java Interface die Annotation \enquote{Transactional} zugewiesen werden. Das Interface muss außerdem das Interface \enquote {CrudRepository} erweitern und den zu behandelnden Objekttyp sowie den Datentyp des Attributs zur Identifikation angeben. Dies ist im folgenden Codeblock als Beispiel aufgeführt.
\begin{lstlisting}[language=Java]
@Transactional
public interface ExampleRepository extends CrudRepository<Example, Long> {
	//optional repository methods
}
\end{lstlisting}

Hierbei sind Methoden zum Speichern, Aktualisieren und Löschen. von Objekten bereits standardmäßig definiert.
Da nach Kapitel \ref{datenmodell} die Objekte der Klassen \enquote{Loaf}, \enquote{Bun}, \enquote{Ingredient}, \enquote{CerealMixPercentage}, \enquote{NewsItem} und \enquote{ApplicationUser} verwaltet werden müssen, werden entsprechende Repository Klassen entwickelt.
Um später im Objektbestand der Klassen \enquote{Loaf}, \enquote{Bun} und \enquote{Ingredient} nach dem Namen suchen zu können, ist eine Methode \enquote{findByName} (siehe folgenden Codeblock) notwendig.
\begin{lstlisting}[language=Java]
Example findByName(String name);
\end{lstlisting}

Des Weiteren soll es möglich sein. einzelne Objekte oder alle Objekte der Klassen \enquote{Loaf}, \enquote{Bun}, \enquote{Ingredient}, \enquote{CerealMixPercentage}, \enquote{NewsItem} und \enquote{ApplicationUser} abzurufen.
Hierfür sind die Methoden \enquote{findById} und \enquote{findAll} (siehe folgenden Codeblock) notwendig.
\begin{lstlisting}[language=Java]
Example findById(long id);
List<Example> findAll();
\end{lstlisting}

Für die Klasse \enquote{ApplicationUser} soll es zudem möglich sein, ein Objekt über den Benutzernamen mit der Methode \enquote{findByUsername} zu finden sowie mit der Methode \enquote{existsByUsername} zu überprüfen, ob bereits ein Benutzer mit einem spezifischen Benutzernamen existiert (siehe folgenden Codeblock).
\begin{lstlisting}[language=Java]
User findByUsername(String username);
boolean existsByUsername(String username);
\end{lstlisting}
Die nach diesem Muster implementierten Repository Klassen mit den jeweiligen Methoden für \enquote{Loaf}, \enquote{Bun}, \enquote{Ingredient}, \enquote{CerealMixPercentage}, \enquote{NewsItem} und \enquote{ApplicationUser} sind in der Abbildung \ref{backend-repositories} als UML Klassendiagramm ersichtlich.

\abbildung{../diagramme/Backend-Repositories.pdf}{Die Repository Ebene des Backends}{backend-repositories}

\clearpage

\subsubsection{Service Ebene}
Die Service Ebene verwendet die Repository Ebene als Abstraktionsschicht über der Datenbank, um vordefinierte Methoden zum Erstellen, Anzeigen, Bearbeiten, und Löschen von Datensätzen zu ermöglichen. Diese Service Klassen werden anschließend von Controller Klassen verwendet und stellen somit selbst eine Abstraktionsschicht dar.
Um eine Klasse als einen Spring Service deklarieren zu können, ist die Verwendung der Annotation \enquote{Service} nowendig.
\begin{lstlisting}[language=Java]
@Service
public class ExampleService {
	//service methods
}
\end{lstlisting}

Da eine Referenz zur jeweiligen Instanz einer Repository Klasse notwendig ist, wird diese durch die Annotation \enquote{Autowired} per Dependency Injection bereitgestellt. Analog gilt des auch für die ModelMapper Klasse, um das Architekturmuster \gls{dto} zu unterstützen.
\begin{lstlisting}[language=Java]
@Autowired
private ModelMapper modelMapper;

@Autowired
private ExampleRepository exampleRepository;
\end{lstlisting}

Hiermit ist die Implementierung neuer Funktionen in den Service Klassen mit Minimalaufwand möglich, wie in dem folgenden Listing zu sehen ist.
\begin{lstlisting}[language=Java]
public Example updateExample(long id, ExampleDTO exampleDTO) {
        Example existingExample = getExampleById(id);

        modelMapper.map(exampleDTO, existingExample);

        return exampleRepository.save(existingExample);
    }
\end{lstlisting}

Nach diesem Schema werden die Service Klassen für \enquote{Loaf}, \enquote{Bun}, \enquote{Ingredient}, \enquote{CerealMixPercentage}, \enquote{NewsItem} und \enquote{ApplicationUser} implementiert. Des Weiteren ist eine Service Klasse mit dem Namen \enquote{FileSystemStorageService} notwendig, welche die Speicherung von Daten auf dem Dateisystem ermöglicht (siehe Abbildung \ref{backend-services}). 

\clearpage

\abbildung{../diagramme/Backend-Services.pdf}{Die Service Ebene des Backends}{backend-services}

\clearpage

\subsubsection{Controller Ebene}
Mit der Repository Ebene ist bereits eine Abstraktionsschicht über der Datenbank und mit der Service Ebene ist eine Abstraktionsschicht für bereitgestellte Funktionalitäten vorhanden. Um nun mit deren Hilfe eine \gls{rest} Schnittstelle anbieten zu können, ist die Controller Ebene notwendig.
Eine Controller Klasse kann mittels der Annotation \enquote{RestController} erstellt werden, wobei der Methoden übergreifende Basis-Endpunkt durch die Annotation \enquote{RequestMapping} deklariert werden kann.
\begin{lstlisting}[language=Java]
@RestController
@RequestMapping("/example")
public class ExampleController {
	//controller methods
}
\end{lstlisting}

Eine Methode kann nun mit Minimalaufwand nach dem folgenden Beispiel implementiert werden.
\begin{lstlisting}[language=Java]
@GetMapping
public List<Example> getAllExamples() {
        return exampleService.getAllExamples();
}
\end{lstlisting}

Damit eine Methode lediglich durch Administratoren aufgerufen werden können, ist die Annotation \enquote{PreAuthorize} notwendig.
\begin{lstlisting}[language=Java]
@PostMapping
@PreAuthorize("hasRole('ROLE_ADMIN')")
public Example createExample(@RequestBody ExampleDTO exampleDTO) {
	return exampleService.createExample(exampleDTO);
}
\end{lstlisting}

Nach diesem Schema werden die Controller Klassen für \enquote{Loaf}, \enquote{Bun}, \enquote{Ingredient}, \enquote{CerealMixPercentage}, \enquote{NewsItem} und \enquote{ApplicationUser} implementiert (siehe Abbildung \ref{backend-controllers}). 

\clearpage

\abbildung{../diagramme/Backend-Controllers.pdf}{Die Controller Ebene des Backends}{backend-controllers}

\clearpage

\section{iOS Applikation}
Damit die Kunden der Bäckerei die im System gespeicherten Daten zu den Produkten anschaulich durchsuchen können, wird eine iOS Applikation entwickelt.
Die Referenz-Implementierung hierzu wird in diesem Kapitel erklärt.

\subsection{Architektur}
Die Architektur der Applikation ist nach dem \gls{mvc} Muster, mit einer Modell Ebene, einer View Ebene und einer Controller Ebene, aufgebaut. Dieses Muster wurde bereits im Kapitel \ref{mvc} ausführlich erläutert und dessen Vorteile aufgezählt.

\subsubsection{Modell Ebene}
Die Modellklassen werden analog zum Datenmodell im Kapitel \ref{datenmodell} implementiert.
Im folgenden Codeblock ist eine beispielhafte, gekürzte Umsetzung in der Programmiersprache Swift für ein Backprodukt ersichtlich.
Die Klasse für das Backprodukt implementiert das Protokoll \enquote{Equatable}, um einen Vergleich zwischen zwei Objekten dieser Klasse nach der Id zu ermöglichen, und das Protokoll  \enquote{Codable}, damit Swift die \gls{json} Daten in Objekte automatisch konvertieren kann.
\begin{lstlisting}[language=Swift]
import Foundation

class BakedGood: Codable, Equatable {
    let id: Int
    var name, characteristic, pictureFilename: String
    var weight, kcal, fat, carbohydrates, protein: Double
    var cerealMix: [CerealMixPercentage]
    var ingredients: [Ingredient]
    
    [...]
    
    static func == (lhs: BakedGood, rhs: BakedGood) -> Bool {
        return lhs.id == rhs.id
    }
}
\end{lstlisting}

\clearpage

\subsubsection{View Ebene}

\clearpage

\subsubsection{Controller Ebene}

\clearpage

\subsection{Anzeige von Broten}

\clearpage

\subsection{Anzeige von Brötchen}

\clearpage

\subsection{Anzeige von Neuigkeiten}

\clearpage

\section{Web Admin-Dashboard}

\subsection{Architektur}

\subsubsection{Component Ebene}

\clearpage

\subsubsection{Page Ebene}

\clearpage

\subsection{Erstellen und bearbeiten von Zutaten}

\clearpage

\subsection{Erstellen und bearbeiten von Broten}

\clearpage

\subsection{Erstellen und bearbeiten von Brötchen}

\clearpage

\subsection{Erstellen und bearbeiten von Neuigkeiten}

\clearpage