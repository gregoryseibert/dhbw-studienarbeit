%!TEX root = ../hauptdatei.tex
\chapter{Implementierung}
In diesem Kapitel wird beschrieben, wie die Backend Komponente und die zwei Frontend Komponenten, eine iOS App sowie ein Web Admin-Dashboard, als Referenz Implementierung entwickelt wird. 

\section{Backend}
Das Backend des Bäckerei Systems ist die zentrale Datenverwaltung, durch die neue Datensätze angelegt oder bestehende Datensätze abgerufen, bearbeitet oder gelöscht werden können. Um neue Datensätze nachhaltig speichern zu können, besitzt das Backend eine Datenbank.
\\
Im Folgenden wird beschrieben, aus welchen Hauptbestandteilen sich das Spring Backend zusammensetzt.
Diese Hauptbestandteile sind die Repository Klassen, die Service Klassen und die Controller Klassen.
Die Controller Klassen nutzen die Service Klassen und die Service Klassen nutzen die Repository Klassen als Abstraktionsschicht über der Datenbank.

\clearpage

\subsubsection{Repository Ebene}
Wie bereits beschrieben, stellt die Repository Ebene eine direkte Abstraktionsschicht der Datenbank dar.
Um eine Repository Klasse erstellen zu können, muss einem Java Interface die Annotation \code{@Transactional} zugewiesen werden. Das Interface muss außerdem das Interface \code {CrudRepository} erweitern und den zu behandelnden Objekttyp sowie den Datentyp des Attributs zur Identifikation angeben. Dies ist im folgenden Codeblock als Beispiel aufgeführt.
\begin{lstlisting}[language=Java]
@Transactional
public interface ExampleRepository extends CrudRepository<Example, Long> {
	//optional repository methods
}
\end{lstlisting}

Hierbei sind Methoden zum Speichern, Aktualisieren und Löschen. von Objekten bereits standardmäßig definiert.
Da nach Kapitel \ref{datenmodell} die Objekte der Klassen \code{Loaf}, \code{Bun}, \code{Ingredient}, \code{CerealMixPercentage}, \code{NewsItem} und \code{ApplicationUser} verwaltet werden müssen, werden entsprechende Repository Klassen entwickelt.
Um später im Objektbestand der Klassen \code{Loaf}, \code{Bun} und \code{Ingredient} nach dem Namen suchen zu können, ist eine Methode \enquote{findByName} (siehe folgenden Codeblock) notwendig.
\begin{lstlisting}[language=Java]
Example findByName(String name);
\end{lstlisting}

Des Weiteren soll es möglich sein. einzelne Objekte oder alle Objekte der Klassen \code{Loaf}, \code{Bun}, \code{Ingredient}, \code{CerealMixPercentage}, \code{NewsItem} und \code{ApplicationUser} abzurufen.
Hierfür sind die Methoden \code{findById} und \code{findAll} (siehe folgenden Codeblock) notwendig.
\begin{lstlisting}[language=Java]
Example findById(long id);
List<Example> findAll();
\end{lstlisting}

Für die Klasse \enquote{ApplicationUser} soll es zudem möglich sein, ein Objekt über den Benutzernamen mit der Methode \code{findByUsername} zu finden sowie mit der Methode \enquote{existsByUsername} zu überprüfen, ob bereits ein Benutzer mit einem spezifischen Benutzernamen existiert (siehe folgenden Codeblock).
\begin{lstlisting}[language=Java]
User findByUsername(String username);
boolean existsByUsername(String username);
\end{lstlisting}
Die nach diesem Muster implementierten Repository Klassen mit den jeweiligen Methoden für \code{Loaf}, \code{Bun}, \code{Ingredient}, \code{CerealMixPercentage}, \code{NewsItem} und \code{ApplicationUser} sind in der Abbildung \ref{backend-repositories} als UML Klassendiagramm ersichtlich.

\abbildung{../diagramme/Backend-Repositories.pdf}{Die Repository Ebene des Backends}{backend-repositories}

\clearpage

\subsubsection{Service Ebene}
Die Service Ebene verwendet die Repository Ebene als Abstraktionsschicht über der Datenbank, um vordefinierte Methoden zum Erstellen, Anzeigen, Bearbeiten, und Löschen von Datensätzen zu ermöglichen. Diese Service Klassen werden anschließend von Controller Klassen verwendet und stellen somit selbst eine Abstraktionsschicht dar.
Um eine Klasse als einen Spring Service deklarieren zu können, ist die Verwendung der Annotation \code{@Service} nowendig.
\begin{lstlisting}[language=Java]
@Service
public class ExampleService {
	//service methods
}
\end{lstlisting}

Da eine Referenz zur jeweiligen Instanz einer Repository Klasse notwendig ist, wird diese durch die Annotation \code{@Autowired} per Dependency Injection bereitgestellt. Analog gilt des auch für die ModelMapper Klasse, um das Architekturmuster \gls{dto} zu unterstützen.
\begin{lstlisting}[language=Java]
@Autowired
private ModelMapper modelMapper;

@Autowired
private ExampleRepository exampleRepository;
\end{lstlisting}

Hiermit ist die Implementierung neuer Funktionen in den Service Klassen mit Minimalaufwand möglich, wie in dem folgenden Listing zu sehen ist.
\begin{lstlisting}[language=Java]
public Example updateExample(long id, ExampleDTO exampleDTO) {
        Example existingExample = getExampleById(id);

        modelMapper.map(exampleDTO, existingExample);

        return exampleRepository.save(existingExample);
    }
\end{lstlisting}

Nach diesem Schema werden die Service Klassen für \code{Loaf}, \code{Bun}, \code{Ingredient}, \code{CerealMixPercentage}, \code{NewsItem} und \code{ApplicationUser} implementiert. Des Weiteren ist eine Service Klasse mit dem Namen \code{FileSystemStorageService} notwendig, welche die Speicherung von Daten auf dem Dateisystem ermöglicht (siehe Abbildung \ref{backend-services}). 

\clearpage

\abbildung{../diagramme/Backend-Services.pdf}{Die Service Ebene des Backends}{backend-services}

\clearpage

\subsubsection{Controller Ebene}
Mit der Repository Ebene ist bereits eine Abstraktionsschicht über der Datenbank und mit der Service Ebene ist eine Abstraktionsschicht für bereitgestellte Funktionalitäten vorhanden. Um nun mit deren Hilfe eine \gls{rest} Schnittstelle anbieten zu können, ist die Controller Ebene notwendig.
Eine Controller Klasse kann mittels der Annotation \code{@RestController} erstellt werden, wobei der Methoden übergreifende Basis-Endpunkt durch die Annotation \code{@RequestMapping} deklariert werden kann.
\begin{lstlisting}[language=Java]
@RestController
@RequestMapping("/example")
public class ExampleController {
	//controller methods
}
\end{lstlisting}

Eine Methode kann nun mit Minimalaufwand nach dem folgenden Beispiel implementiert werden.
\begin{lstlisting}[language=Java]
@GetMapping
public List<Example> getAllExamples() {
        return exampleService.getAllExamples();
}
\end{lstlisting}

Damit eine Methode lediglich durch Administratoren aufgerufen werden können, ist die Annotation \code{PreAuthorize} notwendig.
\begin{lstlisting}[language=Java]
@PostMapping
@PreAuthorize("hasRole('ROLE_ADMIN')")
public Example createExample(@RequestBody ExampleDTO exampleDTO) {
	return exampleService.createExample(exampleDTO);
}
\end{lstlisting}

Nach diesem Schema werden die Controller Klassen für \code{Loaf}, \code{Bun}, \code{Ingredient}, \code{CerealMixPercentage}, \code{NewsItem} und \code{ApplicationUser} implementiert (siehe Abbildung \ref{backend-controllers}). 

\clearpage

\abbildung{../diagramme/Backend-Controllers.pdf}{Die Controller Ebene des Backends}{backend-controllers}

\clearpage

\section{iOS Applikation}
Damit die Kunden der Bäckerei die im System gespeicherten Daten zu den Produkten anschaulich durchsuchen können, wird eine iOS Applikation entwickelt.
Die Referenz-Implementierung hierzu wird in diesem Kapitel erklärt.

\subsection{Architektur}
Die Architektur der Applikation ist nach dem \gls{mvc} Muster, mit einer Modell Ebene, einer View Ebene und einer Controller Ebene, aufgebaut. Dieses Muster wurde bereits im Kapitel \ref{mvc} erläutert.
Zur Entkopplung der Abhängigkeiten wird die Logik zur Kommunikation mit dem Backend und zur lokalen Speicherung der Daten als eigene Schicht, die Datasource Ebene, abstrahiert.
Dies bietet den Vorteil, im späteren Verlauf die Datenquelle auszutauschen, ohne die Klassen der Controller Ebene im großen Maße abzuändern. 

\subsubsection{Datasource Ebene}
Zur lokalen Speicherung der Daten ist die Klasse \code{Disk} zuständig.
Sie besitzt die private Methode \code{getURL}, um die \gls{url} zurückzugeben, welche durch iOS für das angegebene Verzeichnis, \code{documents} oder \code{caches}, zur Verfügung gestellt wird und die den spezifischen Speicherort repräsentiert.
Ihre private Methode \code{storeData} speichert die übergebenen Daten unter dem angegebenen Verzeichnis, indem sie die Funktion \code{getURL} verwendet, ab.
Die Funktion \code{storeCodable}  sorgt für die Umwandlung eines Objekts, dessen Klassen dem \code{Codable} Protokoll entspricht, in Daten und speichert diese Daten durch Verwendung der privaten Funktion \code{storeData} und unter der Angabe des Verzeichnisses ab.
Damit bereits gespeicherte Daten abgerufen werden können, besitzt sie die private Funktion \code{fetchData}. Diese wird von der Funktion \code{fetchCodable} verwendet, um aus den ausgelesenen Daten wiederum Objekte der angegebenen Klasse zu generieren.
Des Weiteren sind Methoden zum Löschen aller Inhalte eines Verzeichnisses mittels \code{clear}, zum Löschen einer Datei mittels \code{remove} und zum Überprüfen der Existenz einer Datei mittels \code{fileExist} implementiert.

\clearpage

Die Klasse \code{RestApiHandler}, ist für die direkte Kommunikation mit einem \gls{rest} Backend zuständig und nutzt hierfür die Swift internen Bibliotheken.
Über die Methode \code{init}, welche in Swift den Konstruktor repräsentiert, wird die Basis \gls{url} gesetzt, welche für alle Anfragen verwendet wird.
Durch ihre private Funktion \code{createRequest} (nicht authentifiziert) oder \code{createAuthenticatedRequest} (authentifiziert) können Anfragen erstellt werden.Damit die authentifizierten Anfragen jedoch durch das Backend auch als solche erkannt werden, muss vorher der Anmeldeprozess mittels der Funktion \code{login} durchlaufen sein.
Die beiden Methoden \code{getDecodableArrayFromEndpoint}, zum Abfragen von Objekten, und \code{getDataFromEndpoint}, zum Abfragen von Ressourcen wie zum Beispiel Bilder, können zum Ausführen von Anfragen verwendet werden.
\\
Die Klasse \code{BakeryDatasource} verwendet die Klasse \code{RestApiHandler}, um spezialisierte Methoden bereitzustellen.
Hierzu gehört \code{login} zum Anmelden sowie \code{existingBakedGoodsOnDisk} zum Überprüfen, ob auf dem lokalen Speicher Objekte der Klasse \code{BakedGood} vorhanden sind.
Des Weiteren werden die Funktionen \code{getBakedGoodsFromAPI} und \code{getBakedGoodsFromDisk}, zum Abrufen von Objekten der Klasse \code{BakedGood} vom Backend oder dem lokalen Speicher, bereitgestellt. Analog dazu werden die Funktionen \code{getNewsItemsFromAPI} und \code{getNewsItemsFromDisk} für die Klasse \code{NewsItem} bereitgestellt.

\subsubsection{Modell Ebene}
Die Modellklassen werden analog zum Datenmodell im Kapitel \ref{datenmodell} implementiert.
Diese Klassen implementieren das Protokoll  \code{Codable}, damit Swift die \gls{json} Daten in Objekte automatisch konvertieren kann. Eine beispielhafte Klasse ist im folgenden Codeblock ersichtlich.
\begin{lstlisting}[language=Swift]
class BakedGood: Codable {
    let id: Int
    var name, characteristic, pictureFilename: String
    var weight, kcal, fat, carbohydrates, protein: Double
    var cerealMix: [CerealMixPercentage]
    var ingredients: [Ingredient]
}
\end{lstlisting}

\clearpage

\subsubsection{View Ebene}
Die Klassen dieser View Ebene werden zum Großteil durch Swift bereitgestellt, so dass nur minimale Anpassungen durch spezialisierende Klassen notwendig sind.
Es wird eine Klasse \code{ImageLabelCollectionViewCell} benötigt, welche eine Spezialisierung der Klasse \code{UICollectionViewCell} darstellt und somit die Zellen einer \code{CollectionView} repräsentiert und sie designt. Instanzen einer \code{CollectionView} besitzen eine Zeile-Spalten Struktur jener Zellen.
Des Weiteren ist die Klasse \code{ColumnFlowLayout} , die die Klasse \code{UICollectionViewFlowLayout} spezialisiert, notwendig, um die Größe der Zellen zu berechnen und zu setzen.

\subsubsection{Controller Ebene}
Die Controller Ebene ist, wie bereits im Kapitel \ref{mvc} erläutert, die Zwischenstelle zur Modell und View Ebene.
Für jede Anzeige von Daten, wie zum Beispiel Brote oder Neuigkeiten, ist ein eigener ViewController notwendig.
Dies lässt sich nochmals in die Controller zur Anzeige von allen Datensätze der jeweiligen Kategorie (Masteransicht) und in die Controller zur Anzeige eines einzelnen Datensatzes (Detailansicht) aufteilen.

\clearpage

\subsection{Anzeige von Broten}

\subsection{Anzeige von Brötchen}

\subsection{Anzeige von Neuigkeiten}

\clearpage

\section{Web Admin-Dashboard}

\subsection{Architektur}

\subsubsection{Component Ebene}

\subsubsection{Page Ebene}

\clearpage

\subsection{Erstellen und bearbeiten von Zutaten}

\subsection{Erstellen und bearbeiten von Broten}

\subsection{Erstellen und bearbeiten von Brötchen}

\subsection{Erstellen und bearbeiten von Neuigkeiten}